x[use]
}
above(x,12)
above(c)
above(x)
above(x,5)
x <- 1:20
above(x,y)
above(x,12)
above(x)
x<- 1:20
above(x)
above <- function(x,n=12 ) {
use <- x > n
x[use]
}
above <- function(x,n=12 ) {
use <- x > n
x[use]
}
above(x)
columnmean <- function (y) {
nc <- ncol(y)
means <- numeric(nc)
for (i in 1:nc) {
means[i] <- mean(y[,i])
}
means
}
columnmean(airquality)
View(columnmean)
View(columnmean)
View(columnmean)
View(columnmean)
View(columnmean)
View(columnmean)
View(columnmean)
columnmean <- function (y, removeNA = TRUE) {
nc <- ncol(y)
means <- numeric(nc)
for (i in 1:nc) {
means[i] <- mean(y[,i], na.rm)
}
means
}
columnmean(airquality)
columnmean <- function (y) {
nc <- ncol(y)
means <- numeric(nc)
for (i in 1:nc) {
means[i] <- mean(y[,i])
}
means
}
columnmean(airquality)
columnmean <- function (y, removeNA=TRUE) {
nc <- ncol(y)
means <- numeric(nc)
for (i in 1:nc) {
means[i] <- mean(y[,i], na.rm)
}
means
}
columnmean(airquality)
columnmean <- function (y, removeNA=TRUE) {
nc <- ncol(y)
means <- numeric(nc)
for (i in 1:nc) {
means[i] <- mean(y[,i], na.rm = removeNA)
}
means
}
columnmean(airquality)
clear
x <- list(a=1:5, b=rnorm(10))
x
lapply(x,mean)
x<-1:4
lapply(x,runif)
v = c(1:3)
v
cat(v,"\n\n")
v
cat(v,'\n\n')
v=c("a","b","c")
v
cat(v,"\n\n")
cat(v, "\n\n")
ls=list("a",2.2)
ls[3]=as.integer(3)
print(ls)
cat(ls[[2]],"\n\n")
m = matrix(0.0,nrow=2, ncol=3)
print(m)
m = matrix(5.0,nrow=2, ncol=3)
m
m = matrix(,nrow=2, ncol=3)
m
arr=array(0.0,3)
arr
arr=array(0.0,c(2,3)
)
arr
arr<-c(2,3)
arr
arr=array(0.0,nrow=2, ncol=3)
arr=array(0.0,2,3)
arr=array(0.0,list(2,3,4,5)
)
arr
arr = array(0.0,c(2,5,4))
arr
x <-list(a=matrix(1:4,2,2),b=matrix(1:6,3,2))
x
x$a[,2]
list(rep(1,4), rep(2,3), rep(3,2), rep(4,1))
mapply(rep, 1:4, 4:1)
x <- c(rnorm(10), runif(10), rnorm(10,1))
f <gl(3,10)
f <-gk(3,10)
f <-gl(3,10)
tapply(x,f,mean)
f
tapply(x,f,range)
library(datasets)
head(airquality)
s<-(split(airquality, airquality$Month))
s
lapply(s, function(x) colMeans(x[c("Ozone", "Solar.R", "Wind")]))
sapply(s, function(x) colMeans(x[c("Ozone", "Solar.R", "Wind")]))
sapply(s, function(x) colMeans(x[c("Ozone", "Solar.R", "Wind")],na.rm=TRUE))
x <- rnorm(10)
f1<-gl(2,5)
f2<-(5,2)
f2<-gl(5,2)
f1 f2
printf(f1, f2)
f1
f2
interactions(f1,f2)
interaction(f1,f2)
str(split(x,list(f1,f2)))
str(split(x,list(f1,f2,drop=TRUE)))
str(split(x,list(f1,f2),drop=TRUE)))
str(split(x,list(f1,f2),drop=TRUE))
log(-1)
printmessage <- function(x) {}
printmessage <- function(x) {
}
printmessage <- function(x) {}
if (x > 0)
}
printmessage(7)
printmessage <- function(x) {
if (x>0)
print("x is greater than zero")
else
print ("x is less than or equal to zero")
invisible(x)
}
printmessage <- function(x) {
if (x>0)
print("x is greater than zero")
else
print ("x is less than or equal to zero")
invisible(x)
}
printmessage(7)
mean(x)
rm(list=ls())
mean(x)
traceback
traceback()
swirl()
install.packages()
install.packages(swirl)
install.packages("swirl")
library("swirl")
swirl()
head(flags)
dim(flags)
viewinfo()
class(flags)
clas_list <- lapply(flags, class)
cls_list <-lapply(flags,class)
cls_list
class(cls_list)
as.character(cls_list)
cls_list <-sapply(flags,class)
cls_vect <-sapply(flags,class)
class(cls_vect)
sum(flags$orange)
flag_colors <-flags[,11:17]
head(flag_colors)
lapply(flag_colors,sum)
sapply(flag_colors,sum)
sapply(flag_colors,mean)
flag_shapes <-flags[,19:23]
lapplu(flag_shapes, range)
lapply(flag_shapes, range)
sapply(flag_shapes, range)
shap_mat<-sapply(flag_shapes, range)
shape_mat<-sapply(flag_shapes, range)
shape_mat
class(shape_mat)
unique(c(3,4,5,5,5,6,6))
unique_vals <- lapply(flags, unique)
unique_vals
sapply(unique_vals, length)
sapply(unique_vals, length)
sapply(flags,unique)
lapply(unique_vals, function(elem) elem[2])
sapply(flags,unique)
sapply(flags,unique, numberic(1))
ok()
sapply(flags,class)
sapply(flags,class, character(1))
vapply(flags,class, character(1))
?tapply
table(flags$landmass)
table(flags$animate)
tapply(flags$animate, flags$landmass, mean)
tapply(flags$population, flag$red,summary)
tapply(flags$population, flags$red,summary)
tapply(flags$population, flags$landmass,summary)
bye()
library(datasets)
data("iris")
?iris
round(mean(iris[which(iris$species=="virginica"),]$Sepal.Length))
round(mean(iris[,which(iris$species=="virginica")]$Sepal.Length))
round(mean(iris[which(iris$species=="virginica"),]$Sepal.Length))
data(iris)
round(mean(iris[which(iris$species=="virginica"),]$Sepal.Length))
round(mean(iris[which(iris$Species=="virginica"),]$Sepal.Length))
library(datasets)
data(mtcars)
?mtcars
with(mtcars,tapply(mpg,cyl,mean))
sapply(split(mtcars$mpg, mtcars$cyl),mean)
tapply(mtcars$mpg,mtcarscyl,mean)
tapply(mtcars$mpg,mtcars$cyl,mean)
new <- tapply(mtcars$hp, mtcars$cyl,mean)
new
round(abs(new[3]-new[1]))
debug(ls)
inv
makeCacheMatrix <- function(x = matrix()) {
inv <- NULL
set <- function(y) {
x <<- y
inv <<- NULL
}
get <- function() x
setInverse <- function(solveMatrix) inv <<- solveMatrix
getInverse <- function() inv
list(set=set,
get=get,
setinverse = setinverse,
getinverse = getinverse)
}
## This functions calculates the inverse of the special matrix retruned by makeCacheMatrix above.
solveCacheMatrix <- function(x, ...) {
## Return a matrix that is the inverse of 'x'
invr <- x$getInverse()
if (!is.null(inv)) {
message("getting cached data")
return(inv)
}
data <- x$get()
inv <-solve(data)
x$setInverse(inv)
inv
}
source("ProgrammingAssignment2/cachmatrix.R")
ls
getwd()
ls
set wd ProgrammingAssignment2/
setwd ("~/ProgrammingAssignment2")
ls
source("ProgrammingAssignment2/cachmatrix.R")
source(~/ProgrammingAssignment2/cachematrix.R)
source("~/ProgrammingAssignment2/cachematrix.R")
my_matrix <- makeCachMatrix(natrix(1:4,2,2))
makeCacheMatrix <- function(x = matrix()) {
inv <- NULL
set <- function(y) {
x <<- y
inv <<- NULL
}
get <- function() x
setInverse <- function(solveMatrix) inv <<- solveMatrix
getInverse <- function() inv
list(set=set,
get=get,
setinverse = setinverse,
getinverse = getinverse)
}
## This functions calculates the inverse of the special matrix retruned by makeCacheMatrix above.
solveCacheMatrix <- function(x, ...) {
## Return a matrix that is the inverse of 'x'
invr <- x$getInverse()
if (!is.null(inv)) {
message("getting cached data")
return(inv)
}
data <- x$get()
inv <-solve(data)
x$setInverse(inv)
inv
}
my_matrix <- makeCacheMatrix(1:4, 2, 2)
my_matrix <- makeCacheMatrix(1:4, 2, 2))
my_matrix <- makeCacheMatrix(matrix(1:4, 2, 2))
##This programs defines two functions that allows user to cache the matrix inverse,
##that could save resources from re-running the same computation.
##This function creates a special matrix that can cache its inverse.
makeCacheMatrix <- function(x = matrix()) {
inv <- NULL
set <- function(y) {
x <<- y
inv <<- NULL
}
get <- function() x
setInverse <- function(solveCacheMatrix) inv <<- solveCacheMatrix
getInverse <- function() inv
list(set=set,
get=get,
setinverse = setinverse,
getinverse = getinverse)
}
## This functions calculates the inverse of the special matrix retruned by makeCacheMatrix above.
solveCacheMatrix <- function(x, ...) {
## Return a matrix that is the inverse of 'x'
invr <- x$getInverse()
if (!is.null(inv)) {
message("getting cached data")
return(inv)
}
data <- x$get()
inv <-solve(data)
x$setInverse(inv)
inv
}
my_matrix <- makeCacheMatrix(matrix(1:4,2,2))
##This programs defines two functions that allows user to cache the matrix inverse,
##that could save resources from re-running the same computation.
##This function creates a special matrix that can cache its inverse.
makeCacheMatrix <- function(x = matrix()) {
inv <- NULL
set <- function(y) {
x <<- y
inv <<- NULL
}
get <- function() x
setInverse <- function(solveMatrix) inv <<- solveMatrix
getInverse <- function() inv
list(set=set,
get=get,
setInverse = setInverse,
getInverse = getInverse)
}
## This functions calculates the inverse of the special matrix retruned by makeCacheMatrix above.
solveCacheMatrix <- function(x, ...) {
## Return a matrix that is the inverse of 'x'
invr <- x$getInverse()
if (!is.null(inv)) {
message("getting cached data")
return(inv)
}
data <- x$get()
inv <-solve(data)
x$setInverse(inv)
inv
}
my_matrix <- makeCacheMatrix(matrix(1:4,2,2))
my_matrix
my_matrix$get()
##This programs defines two functions that allows user to cache the matrix inverse,
##that could save resources from re-running the same computation.
##This function creates a special matrix that can cache its inverse.
makeCacheMatrix <- function(x = matrix()) {
inv <- NULL
set <- function(y) {
x <<- y
inv <<- NULL
}
get <- function() x
setInverse <- function(solveMatrix) inv <<- solveMatrix
getInverse <- function() inv
list(set=set,
get=get,
setInverse = setInverse,
getInverse = getInverse)
}
## This functions calculates the inverse of the special matrix returned by makeCacheMatrix above.
solveCacheMatrix <- function(x, ...) {
## Return a matrix that is the inverse of 'x'
inv <- x$getInverse()
if (!is.null(inv)) {
message("getting cached data")
return(inv)
}
data <- x$get()
inv <-solve(data)
x$setInverse(inv)
inv
}
my_matrix <- makeCacheMatrix(matrix(1:4,2,2))
my_matrix$get()
my_matrix$getInverse()
##This programs defines two functions that allows user to cache the matrix inverse,
##that could save resources from re-running the same computation.
##This function creates a special matrix that can cache its inverse.
makeCacheMatrix <- function(x = matrix()) {
inv <- NULL
set <- function(y) {
x <<- y
inv <<- NULL
}
get <- function() x
setInverse <- function(solveMatrix) inv <<- solveMatrix
getInverse <- function() inv
list(set=set,
get=get,
setInverse = setInverse,
getInverse = getInverse)
}
## This functions calculates the inverse of the special matrix returned by makeCacheMatrix above.
CacheSolve <- function(x, ...) {
## Return a matrix that is the inverse of 'x'
inv <- x$getInverse()
if (!is.null(inv)) {
message("getting cached data")
return(inv)
}
data <- x$get()
inv <-solve(data)
x$setInverse(inv)
inv
}
##This programs defines two functions that allows user to cache the matrix inverse,
##that could save resources from re-running the same computation.
##This function creates a special matrix that can cache its inverse.
makeCacheMatrix <- function(x = matrix()) {
inv <- NULL
set <- function(y) {
x <<- y
inv <<- NULL
}
get <- function() x
setInverse <- function(solveMatrix) inv <<- solveMatrix
getInverse <- function() inv
list(set=set,
get=get,
setInverse = setInverse,
getInverse = getInverse)
}
## This functions calculates the inverse of the special matrix returned by makeCacheMatrix above.
CacheSolve <- function(x, ...) {
## Return a matrix that is the inverse of 'x'
inv <- x$getInverse()
if (!is.null(inv)) {
message("getting cached data")
return(inv)
}
data <- x$get()
inv <-solve(data)
x$setInverse(inv)
inv
}
my_matrix$getInverse()
my_matrix$cacheSolve()
cacheSolve(my_matrix)
##This programs defines two functions that allows user to cache the matrix inverse,
##that could save resources from re-running the same computation.
##This function creates a special matrix that can cache its inverse.
makeCacheMatrix <- function(x = matrix()) {
inv <- NULL
set <- function(y) {
x <<- y
inv <<- NULL
}
get <- function() x
setInverse <- function(solveMatrix) inv <<- solveMatrix
getInverse <- function() inv
list(set=set,
get=get,
setInverse = setInverse,
getInverse = getInverse)
}
## This functions calculates the inverse of the special matrix returned by makeCacheMatrix above.
cacheSolve <- function(x, ...) {
## Return a matrix that is the inverse of 'x'
inv <- x$getInverse()
if (!is.null(inv)) {
message("getting cached data")
return(inv)
}
data <- x$get()
inv <-solve(data)
x$setInverse(inv)
inv
}
mymatrix <-makeCacheMatrix(matrix(1:4,2,2))
mymatrix
mymatrix$get()
mymatrix$getInverse()
cacheSolve(mymatrix)
cacheSolve(mymatrix)
mymatrix$getInverse()
